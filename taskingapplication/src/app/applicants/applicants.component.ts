import { Component, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { SidenavComponent } from '../sidenav/sidenav.component';
import { DataService, Applicant, ApplicantDocument } from '../data.service';
import { EmailService } from '../email.service';
import { ConfirmationModalComponent } from '../confirmation-modal/confirmation-modal.component';
import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';
import { FormsModule } from '@angular/forms';
import { RowInput } from 'jspdf-autotable';

interface ApplicantWithDocuments extends Applicant {
  documents: ApplicantDocument[];
}
@Component({
  selector: 'app-applicants',
  standalone: true,
  imports: [CommonModule, SidenavComponent, ConfirmationModalComponent, FormsModule],
  templateUrl: './applicants.component.html',
  styleUrls: ['./applicants.component.css']
})
export class ApplicantsComponent implements OnInit {
  applicants: ApplicantWithDocuments[] = [];
  selectedApplicant: ApplicantWithDocuments | null = null;
  loading = false;
  showDetails = false;
  showModal = false;
  modalType: 'accept' | 'reject' = 'accept';
  pendingApplicantId: number | null = null;
  selectedReportType: string = '';
  currentUser: string = 'admin';
  currentDateTime: string = new Date().toISOString().slice(0, 19).replace('T', ' '); // YYYY-MM-DD HH:MM:SS format


  constructor(
    private dataService: DataService,
    private emailService: EmailService
  ) {}


  ngOnInit(): void {
    this.loadApplicants();
  }
  
  viewReport() {
    if (!this.selectedReportType) return;
    
    const doc = new jsPDF();
    let title = '';
    let data: any[] = [];

    switch (this.selectedReportType) {
        case 'approved':
            title = 'Approved Applicants Report';
            data = this.applicants.filter(app => app.status === 'Approved');
            break;
        case 'pending':
            title = 'Pending Applicants Report';
            data = this.applicants.filter(app => app.status === 'Pending');
            break;
        case 'rejected':  // Add this case
            title = 'Rejected Applicants Report';
            data = this.applicants.filter(app => app.status === 'Rejected');
            break;
        case 'department':
            title = 'Applicants by Department Report';
            const departmentGroups = this.groupByDepartment(this.applicants);
            data = this.formatDepartmentData(departmentGroups);
            break;
        case 'civilStatus':
            title = 'Applicants by Civil Status Report';
            const statusGroups = this.groupByCivilStatus(this.applicants);
            data = this.formatCivilStatusData(statusGroups);
            break;
    }

    this.generatePDFContent(doc, title, data, true);
}

  private generatePDFContent(doc: jsPDF, title: string, data: any[], isPreview: boolean) {
    // Add header with logo or company name
    doc.setFontSize(20);
    
    
    // Add report title
    doc.setFontSize(16);
    doc.text(title, 105, 25, { align: 'center' });
    
    // Add metadata
    doc.setFontSize(10);
    doc.text(`Generated by: ${this.currentUser}`, 14, 35);
    doc.text(`Date: ${this.currentDateTime}`, 14, 40);

    // Get headers and convert to proper format
    const headers: RowInput[] = [this.getTableHeaders().map(header => ({ content: header }))];
    const tableData: RowInput[] = this.getTableData(data).map(row => 
      row.map(cell => ({ content: cell.toString() }))
    );

    autoTable(doc, {
      startY: 45,
      head: headers,
      body: tableData,
      theme: 'grid',
      styles: {
        fontSize: 10,
        cellPadding: 5,
        overflow: 'linebreak',
      },
      headStyles: {
        fillColor: [41, 128, 185],
        textColor: 255,
        fontStyle: 'bold',
      },
      alternateRowStyles: {
        fillColor: [245, 245, 245],
      },
      margin: { top: 45 },
    });

    // Add footer with page numbers
    const pageCount = doc.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
      doc.setPage(i);
      doc.setFontSize(10);
      doc.text(
        `Page ${i} of ${pageCount}`,
        doc.internal.pageSize.width / 2,
        doc.internal.pageSize.height - 10,
        { align: 'center' }
      );
    }

    if (isPreview) {
      // Open in new tab for preview
      window.open(URL.createObjectURL(doc.output('blob')));
    } else {
      // Download the file
      const fileName = `${title.toLowerCase().replace(/\s+/g, '_')}_${this.currentDateTime.replace(/[: ]/g, '_')}.pdf`;
      doc.save(fileName);
    }
  }

  private getTableData(data: any[]): any[][] {
    switch (this.selectedReportType) {
        case 'approved':
        case 'pending':
        case 'rejected':  // Add this case
            return data.map(app => [
                `${app.last_name}, ${app.first_name} ${app.middle_name || ''}`.trim(),
                app.email,
                app.department,
                app.position,
                app.status
            ]);
        case 'department':
            return data;
        case 'civilStatus':
            return data;
        default:
            return [];
    }
}

  generateReport() {
    if (!this.selectedReportType) return;
    
    const doc = new jsPDF();
    let title = '';
    let data: any[] = [];

    switch (this.selectedReportType) {
        case 'approved':
            title = 'Approved Applicants Report';
            data = this.applicants.filter(app => app.status === 'Approved');
            break;
        case 'pending':
            title = 'Pending Applicants Report';
            data = this.applicants.filter(app => app.status === 'Pending');
            break;
        case 'rejected':  // Add this case
            title = 'Rejected Applicants Report';
            data = this.applicants.filter(app => app.status === 'Rejected');
            break;
        case 'department':
            title = 'Applicants by Department Report';
            const departmentGroups = this.groupByDepartment(this.applicants);
            data = this.formatDepartmentData(departmentGroups);
            break;
        case 'civilStatus':
            title = 'Applicants by Civil Status Report';
            const statusGroups = this.groupByCivilStatus(this.applicants);
            data = this.formatCivilStatusData(statusGroups);
            break;
    }

    this.generatePDFContent(doc, title, data, false);
}

  private groupByDepartment(applicants: any[]) {
    return applicants.reduce((groups: any, app: any) => {
      const dept = app.department || 'Unspecified';
      if (!groups[dept]) {
        groups[dept] = [];
      }
      groups[dept].push(app);
      return groups;
    }, {});
  }

  private groupByCivilStatus(applicants: any[]) {
    return applicants.reduce((groups: any, app: any) => {
      const status = app.civil_status || 'Unspecified';
      if (!groups[status]) {
        groups[status] = [];
      }
      groups[status].push(app);
      return groups;
    }, {});
  }

  private formatDepartmentData(groups: any): any[][] {
    const data: any[][] = [];
    Object.entries(groups).forEach(([dept, apps]: [string, any]) => {
      (apps as any[]).forEach((app: any) => {
        data.push([
          dept,
          `${app.last_name}, ${app.first_name} ${app.middle_name || ''}`,
          app.position,
          app.status
        ]);
      });
    });
    return data;
  }

  private formatCivilStatusData(groups: any): any[][] {
    const data: any[][] = [];
    Object.entries(groups).forEach(([status, apps]: [string, any]) => {
      (apps as any[]).forEach((app: any) => {
        data.push([
          status,
          `${app.last_name}, ${app.first_name} ${app.middle_name || ''}`,
          app.department,
          app.status
        ]);
      });
    });
    return data;
  }


  private getTableHeaders(): string[] {
    switch (this.selectedReportType) {
        case 'approved':
        case 'pending':
        case 'rejected':  // Add this case
            return ['Name', 'Email', 'Department', 'Position', 'Status'];
        case 'department':
            return ['Department', 'Name', 'Position', 'Status'];
        case 'civilStatus':
            return ['Civil Status', 'Name', 'Department', 'Status'];
        default:
            return [];
    }
}


  private getTableBody(data: any[]): any[][] {
    switch (this.selectedReportType) {
      case 'approved':
      case 'pending':
        return data.map(app => [
          `${app.last_name}, ${app.first_name}`,
          app.email,
          app.department,
          app.position,
          app.status
        ]);
      // For department and civil status reports, the data is already formatted
      default:
        return data;
    }
  }

  viewDocument(documentId: number): void {
    this.dataService.viewDocument(documentId).subscribe({
      error: (error) => console.error('Error viewing document:', error)
    });
  }

  downloadDocument(documentId: number): void {
    this.dataService.downloadDocument(documentId).subscribe({
      next: (blob: Blob) => {
        const url = window.URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        // You might want to get the actual filename from the document metadata
        link.download = `document-${documentId}`;
        link.click();
        window.URL.revokeObjectURL(url);
      },
      error: (error) => console.error('Error downloading document:', error)
    });
  }

  // Your existing methods...
  loadApplicants(): void {
    this.loading = true;
    this.dataService.getApplicants().subscribe({
      next: (applicants) => {
        this.applicants = applicants.map(applicant => ({
          ...applicant,
          documents: [],
          department: applicant.department || '',
          position: applicant.position || ''
        }));
        this.loading = false;
      },
      error: (error) => {
        console.error('Error loading applicants:', error);
        this.loading = false;
      }
    });
  }
  
  selectApplicant(applicant: ApplicantWithDocuments): void {
    if (this.selectedApplicant?.applicant_id === applicant.applicant_id) {
      this.selectedApplicant = null;
      this.showDetails = false;
    } else {
      this.selectedApplicant = {
        ...applicant,
        documents: []
      };
      this.showDetails = true;
      this.loadApplicantDocuments(applicant);
    }
  }

  loadApplicantDocuments(applicant: Applicant): void {
    this.selectedApplicant = { ...applicant, documents: [] };  // Initialize with empty documents array
    this.dataService.getApplicantDocuments(applicant.applicant_id).subscribe({
      next: (documents) => {
        if (this.selectedApplicant) {
          this.selectedApplicant = {
            ...this.selectedApplicant,
            documents: documents
          };
        }
      },
      error: (error) => console.error('Error loading documents:', error)
    });
  }

  acceptApplicant(event: Event, applicantId: number): void {
    event.stopPropagation();
    this.showModal = true;
    this.pendingApplicantId = applicantId;
  }

  declineApplicant(event: Event, applicantId: number): void {
    event.stopPropagation();
    this.dataService.updateApplicantStatus(applicantId, 'Rejected').subscribe({
      next: () => {
        const applicant = this.applicants.find(a => a.applicant_id === applicantId);
        if (applicant) {
          this.applicants = this.applicants.map(a => {
            if (a.applicant_id === applicantId) {
              return { ...a, status: 'Rejected' };
            }
            return a;
          });

          this.emailService.sendRejectionEmail(applicant).subscribe({
            next: () => console.log('Rejection email sent successfully'),
            error: (error) => console.error('Error sending rejection email:', error)
          });
        }
      },
      error: (error) => console.error('Error rejecting applicant:', error)
    });
  }

  onSidenavHover(isHovered: boolean): void {
    console.log('Sidenav hover state changed:', isHovered);
  }

  getStatusClass(status: string): string {
    return status.toLowerCase().replace(' ', '-');
  }

  onModalConfirm(customMessage: string): void {
    if (!this.pendingApplicantId) return;
    
    this.dataService.updateApplicantStatus(this.pendingApplicantId, 'Approved').subscribe({
      next: () => {
        const applicant = this.applicants.find(a => a.applicant_id === this.pendingApplicantId);
        if (applicant) {
          this.applicants = this.applicants.map(a => {
            if (a.applicant_id === this.pendingApplicantId) {
              return { ...a, status: 'Approved' };
            }
            return a;
          });

          this.emailService.sendAcceptanceEmail(applicant, customMessage).subscribe({
            next: () => console.log('Acceptance email sent successfully'),
            error: (error) => console.error('Error sending acceptance email:', error)
          });
        }
        this.closeModal();
      },
      error: (error) => console.error('Error accepting applicant:', error)
    });
  }

  closeModal(): void {
    this.showModal = false;
    this.pendingApplicantId = null;
  }

}